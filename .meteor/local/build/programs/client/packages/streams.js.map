)]}'
{"version":3,"file":"/packages/streams.js","sources":["streams/lib/ev.js","streams/lib/client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,gB;AACA,kB;AACA,oB;;AAEA,oC;AACA,wD;;AAEA,yB;AACA,sD;AACA,0C;AACA,kC;AACA,O;AACA,K;AACA,I;;AAEA,0C;AACA,0B;AACA,2B;AACA,K;AACA,mC;AACA,I;;AAEA,8C;AACA,+C;AACA,sC;AACA,kD;AACA,O;AACA,I;;AAEA,kE;AACA,yB;AACA,oD;AACA,uC;AACA,K;AACA,I;;AAEA,gE;AACA,gC;AACA,I;AACA,C;;AAEA,S;;;;;;;;;;;;;;;;;;ACzCA,iD;AACA,gB;AACA,E;AACA,kB;AACA,oC;AACA,qD;AACA,mB;AACA,qB;;AAEA,wB;AACA,yB;;AAEA,yB;;AAEA,+B;AACA,6B;AACA,yC;AACA,kC;AACA,yB;AACA,8C;AACA,sC;AACA,W;AACA,2B;AACA,c;AACA,yB;AACA,qD;AACA,qC;AACA,iD;AACA,O;AACA,K;AACA,K;;AAEA,wD;;AAEA,+B;AACA,mB;AACA,yD;AACA,Y;AACA,oC;AACA,K;AACA,I;;AAEA,iC;AACA,wB;AACA,I;AACA,C;;AAEA,gD","sourcesContent":["function _EV() {\n  var self = this;\n  var handlers = {};\n\n  self.emit = function emit(event) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    if(handlers[event]) {\n      for(var lc=0; lc<handlers[event].length; lc++) {\n        var handler = handlers[event][lc];\n        handler.apply(this, args);\n      }\n    }\n  };\n\n  self.on = function on(event, callback) {\n    if(!handlers[event]) {\n      handlers[event] = [];\n    }\n    handlers[event].push(callback);\n  };\n\n  self.once = function once(event, callback) {\n    self.on(event, function onetimeCallback() {\n      callback.apply(this, arguments);\n      self.removeListener(event, onetimeCallback);\n    });\n  };\n\n  self.removeListener = function removeListener(event, callback) {\n    if(handlers[event]) {\n      var index = handlers[event].indexOf(callback);\n      handlers[event].splice(index, 1);\n    }\n  };\n\n  self.removeAllListeners = function removeAllListeners(event) {\n    handlers[event] = undefined;\n  };\n}\n\nEV = _EV;","Meteor.Stream = function Stream(name, callback) {\n  EV.call(this);\n  \n  var self = this;\n  var streamName = 'stream-' + name;\n  var collection = new Meteor.Collection(streamName);\n  var subscription;\n  var subscriptionId;\n\n  var connected = false;\n  var pendingEvents = [];\n\n  self._emit = self.emit;\n\n  collection.find({}).observe({\n    \"added\": function(item) {\n      if(item.type == 'subscriptionId') {\n        subscriptionId = item._id;\n        connected = true;\n        pendingEvents.forEach(function(args) {\n          self.emit.apply(self, args);\n        });\n        pendingEvents = [];\n      } else {\n        var context = {};\n        context.subscriptionId = item.subscriptionId;\n        context.userId = item.userId;\n        self._emit.apply(context, item.args);    \n      }\n    }\n  });\n\n  subscription = Meteor.subscribe(streamName, callback);\n\n  self.emit = function emit() {\n    if(connected) {\n      Meteor.call(streamName, subscriptionId, arguments);\n    } else {\n      pendingEvents.push(arguments);\n    }\n  };\n\n  self.close = function close() {\n    subscription.stop();\n  };\n}\n\n_.extend(Meteor.Stream.prototype, EV.prototype);\n"]}